# parse_spec_tool.py

import os
import json
import re
from typing import Dict, Any


def parse_spec_tool(inp: Dict[str, Any], content_llm: Any) -> Dict[str, Any]:
    """
    Parse a natural language spec document, extract feature descriptions, use LLM to generate verbose feature descriptions,
    and output those descriptions as a JSON file compatible with extract_test_requirements_tool.

    Input:
    - {"spec_path": "examples/amba_ahb_lite_spec.txt"}
    - content_llm: an instance of the LLM service

    Output:
    - JSON file containing a list of features (compatible with extract_test_requirements_tool)
    """

    spec_path = inp.get("spec_path")
    if not spec_path:
        return {"error": "spec_path required"}

    try:
        # Read the natural language spec document (plain text file)
        with open(spec_path, "r") as f:
            spec_text = f.read()

        # Extract feature names using regular expressions
        features = extract_feature_headings(spec_text)

        # Process each feature and generate verbose descriptions using LLM
        feature_list = []
        for feature in features:
            if feature:
                # Construct prompt for LLM to get detailed descriptions
                description = generate_feature_description(feature, content_llm)

                # Build the structure compatible with extract_test_requirements_tool
                feature_data = {
                    "feature": feature,
                    "test_requirements": {
                        "scenarios_needed": 2,  # You can adjust this based on your spec
                        "scenario_types": [
                            "normal_operation",
                            "edge_case",
                        ],  # Adjust this as needed
                        "coverage_mapping": {
                            "normal_operation": "fsm_states",  # Example
                            "edge_case": "addr_alignments",  # Example
                        },
                        "test_focus": description,  # Use LLM-generated description as the test focus
                    },
                }

                feature_list.append(feature_data)

        # Output file path for verbose feature descriptions
        output_file_path = "parsed_spec/feature_descriptions.json"
        os.makedirs(os.path.dirname(output_file_path), exist_ok=True)

        # Write the feature list to the JSON file
        with open(output_file_path, "w") as output_file:
            json.dump(feature_list, output_file, indent=2)

        return {"success": f"Feature descriptions saved to {output_file_path}"}

    except Exception as e:
        return {"error": str(e)}


def extract_feature_headings(spec_text: str) -> list:
    """
    Extract feature names from a natural language specification document using regex.
    This function identifies section headings and uses them as feature names.

    Input:
    - spec_text (str): The text content of the spec document

    Output:
    - List of feature descriptions (each a string)
    """
    features = []
    section_pattern = r"\d+\.\d+\s+([A-Za-z0-9\s\-]+)"
    sections = re.findall(section_pattern, spec_text)
    return sections


def generate_feature_description(feature: str, content_llm: Any) -> str:
    """
    Given a feature name, ask the LLM to generate a detailed description.

    Input:
    - feature (str): The feature name
    - content_llm: an instance of the LLM service

    Output:
    - A detailed description generated by the LLM
    """
    prompt = f"""
    You are a verification engineer. Please analyze and explain the following feature in detail, covering the following aspects:
    1. **Core Functionality**: What does the feature do? What are the primary tasks it performs?
    2. **Key Behaviors**: What is the expected behavior of this feature under normal conditions? What conditions trigger this feature to act?
    3. **Edge Cases & Limitations**: What are the potential edge cases, limitations, or exceptional conditions where this feature might behave differently?
    4. **Use Cases**: Where is this feature typically used, and in what scenarios?

    Feature: {feature}

    Output ONLY JSON:
    {{
      "description": "detailed explanation of the feature, including functionality, key behaviors, edge cases, and use cases"
    }}
    """

    feature_description = content_llm.generate_description(prompt)
    return feature_description
